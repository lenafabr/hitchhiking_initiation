PROGRAM MAIN

  USE PARTICLEUTIL, ONLY : PARTICLEGROUP, SETUPPARTICLEGROUP,SETPARTPARAMS,INITIALIZEPARTICLES,CLEANUPPARTICLEGROUP,GETINITPOS
  USE KEYS, ONLY : ACTION,ATTLEN,DOMRAD,DOMLEN,KSP,KT,KTETH,NPART,NTETH,NTRACK,&
       &NTRIALS,NWALK,STERRAD,TETHINDS,WALKINDS, NRXN
  USE ROTATION
  USE GENUTIL, ONLY : PI
  USE MT19937, ONLY : GRND,RNORM

  IMPLICIT NONE
  TYPE(PARTICLEGROUP), POINTER :: PARTGROUP(:)
  TYPE(PARTICLEGROUP), POINTER :: PARTP

  DOUBLE PRECISION,ALLOCATABLE :: INITPOS(:,:),INITQ(:,:),INITPOSTRK(:,:),INITSPRPOS(:,:)
  DOUBLE PRECISION :: KSP0,TH,X0,Y0,R0,Z0,XT,YT,TMP(3), DIST, T1,T2, MULT = 1D0
  INTEGER :: TC,PC,IND,LC, CNT 
  LOGICAL :: DISTFLAG = .TRUE.

  CALL CPU_TIME(T1)
  CALL READKEY

  ALLOCATE(PARTGROUP(NTRIALS))
  ALLOCATE(INITPOS(3,NPART),INITQ(4,NPART),INITPOSTRK(3,NTRACK),INITSPRPOS(3,NPART))

  INITPOS = 0D0
  INITQ = 0D0
  INITPOSTRK = 0D0
  INITSPRPOS = 0D0

  ! Set up and initialize group of particles
  !  DO TC = 1,NTRIALS
  !	  PARTP=>PARTGROUP(TC)
  !	  CALL SETUPPARTICLEGROUP(PARTP,NPART,NWALK,NTETH,NTRACK)
  !	  CALL SETPARTPARAMS(PARTP)
  !  END DO

  KSP0 = KSP


  SELECT CASE (ACTION)
  CASE ('BROWNDYN')
     DO TC = 1,NTRIALS
        PARTP=>PARTGROUP(TC)
        CALL GETINITPOS(PARTP,INITPOS)
        CALL INITIALIZEPARTICLES(PARTP, INITPOS(:,1:NPART))!,RANDORIENT=.true.)
     END DO
     CALL BROWNDYNDRIVER(PARTGROUP)


  CASE('PARTINTERACT')
     ! INTERACTING PARTICLES, NUMBER OF WALKING AND DIFFUSIVE/TETHERED PARTICLES SPECIFIED

     DO TC = 1,NTRIALS
        ! IF MULTIPLE MICROTUBULES, DISTRIBUTE TRACKS UNIFORMLY
        PARTP=>PARTGROUP(TC)
        CALL SETUPPARTICLEGROUP(PARTP,NPART,NWALK,NTETH,NTRACK,NRXN)
        CALL SETPARTPARAMS(PARTP)

        DO PC = 1,NPART
           ATTLEN = STERRAD(PC)
           IF(ANY(WALKINDS.EQ.PC)) THEN
              !WALKERS START UNIFORMLY DISTRIBUTED THROUGHOUT THE DOMAIN
              DISTFLAG = .TRUE.
              CNT = 0
              DO WHILE (DISTFLAG)
                 ! CHOOSE MICROTUBULE
                 IND = CEILING(GRND()*NTRACK)
                 PARTP%PARTTRACK(PC) = IND
                 XT = PARTP%TRKPOS(1,IND)
                 YT = PARTP%TRKPOS(2,IND)

                 ! ORIENT PARTICLE CENTER RELATIVE TO MICROTUBULE
                 TH = 2*PI*GRND()
                 X0 = XT+ATTLEN*COS(TH)
                 Y0 = YT+ATTLEN*SIN(TH)
                 IF((X0**2+Y0**2).GT.(DOMRAD-ATTLEN)) CYCLE
                 Z0 = DOMLEN*(2*GRND()-1)
                 DISTFLAG = .FALSE.
                 DO LC = 1,NPART
                    IF(LC.EQ.PC) CYCLE
                    TMP = INITPOS(:,LC)-(/X0,Y0,Z0/)
                    DIST = SQRT(DOT_PRODUCT(TMP,TMP))
                    IF(DIST.LT.MULT*(STERRAD(PC)+STERRAD(LC))) THEN
                       DISTFLAG = .TRUE.
                       CNT = CNT+1
                       IF(CNT.GT.1E4) THEN
                          MULT = 0.9*MULT
                          CNT = 0
                       END IF
                       EXIT
                    END IF
                 END DO
              END DO


              INITPOS(:,PC) = (/X0,Y0,Z0/)
              INITSPRPOS(:,PC) = (/XT,YT,Z0/)
              CALL ROTQUAT(TH,(/0D0,0D0,1D0/),INITQ(:,PC))
              !							INITQ(:,PC) = (/1D0,0D0,0D0,0D0/)
           ELSE IF(ANY(TETHINDS.EQ.PC)) THEN
              !PARTICLES START TETHERED TO A RANDOM TRACK
              DISTFLAG = .TRUE.
              CNT = 0
              DO WHILE (DISTFLAG)
                 ! CHOOSE MICROTUBULE
                 IND = CEILING(GRND()*NTRACK)
                 PARTP%PARTTRACK(PC) = IND
                 XT = PARTP%TRKPOS(1,IND)
                 YT = PARTP%TRKPOS(2,IND)

                 !ORIENT PARTICLE CENTER RELATIVE TO MICROTUBULE
                 TH = 2*PI*GRND()
                 X0 = XT+ATTLEN*COS(TH)
                 Y0 = YT+ATTLEN*SIN(TH)
                 IF((X0**2+Y0**2).GT.(DOMRAD-ATTLEN)) THEN
                    CYCLE
                 ELSE
                    DISTFLAG = .FALSE.
                 END IF
              END DO
              INITPOS(:,PC) = (/X0,Y0,0D0/)
              INITSPRPOS(:,PC) = (/XT,YT,0D0/)
              CALL ROTQUAT(TH,(/0D0,0D0,1D0/),INITQ(:,PC))
           ELSE
              !DIFFUSERS START AT Z=0, DISTRIBUTED UNIFORMLY
              TH = 2*PI*GRND()
              R0 = (DOMRAD-STERRAD(PC))*SQRT(GRND())
              INITPOS(:,PC) = (/R0*COS(TH),R0*SIN(TH),0D0/)
              !INITIAL QUATERNION
              CALL ROTQUAT(TH,(/0D0,0D0,1D0/),INITQ(:,PC))
           END IF
        END DO
        CALL INITIALIZEPARTICLES(PARTP, INITPOS(:,1:NPART),INITQ(:,1:NPART),INITSPRPOS(:,1:NPART))

     END DO

     CALL BROWNDYNDRIVER(PARTGROUP)

  CASE('SPRBEAD')
     ! SINGLE PARTICLE ATTACHED TO A SPRING

     !Spring attached to bead center
     ATTLEN = 0D0

     !Initial position at origin
     INITPOS(:,1) = (/0D0,0D0,0D0/)

     DO TC = 1,NTRIALS
        PARTP=>PARTGROUP(TC)
        CALL INITIALIZEPARTICLES(PARTP, INITPOS(:,1:NPART))!,RANDORIENT=.true.)
     END DO
     CALL BROWNDYNDRIVER(PARTGROUP)

  CASE('SPRWALK')
     ! SINGLE PARTICLE WALKING

     !SPRING ATTACHED TO BEAD SURFACE
     ATTLEN = STERRAD(WALKINDS(1))

     !WALKER STARTS AT THE CENTER OF THE CYLINDER
     INITPOS(:,1) = (/ATTLEN,0D0,0D0/)

     !INITIAL QUATERNION
     !				CALL ROTQUAT(PI/2,(/0D0,0D0,1D0/),INITQ)

     DO TC = 1,NTRIALS
        PARTP=>PARTGROUP(TC)
        CALL INITIALIZEPARTICLES(PARTP, INITPOS(:,1:NPART))!,RANDORIENT=.true.)
        !				PARTP%QUAT(:,WALKIND) = INITQ
     END DO
     CALL BROWNDYNDRIVER(PARTGROUP)


  CASE ('TETHDIFF')
     ! SINGLE PARTICLE SWITCHING BETWEEN TETHERED AND DIFFUSIVE STATES

     !SPRING ATTACHED TO BEAD SURFACE
     ATTLEN = STERRAD(WALKINDS(1))

     !WALKER STARTS AT DOMAIN CENTER
     INITPOS(:,1) = (/ATTLEN,0D0,0D0/)

     DO TC = 1,NTRIALS
        PARTP=>PARTGROUP(TC)
        CALL INITIALIZEPARTICLES(PARTP, INITPOS(:,1:NPART))!,RANDORIENT=.true.)
     END DO
     CALL BROWNDYNDRIVER(PARTGROUP)

  CASE DEFAULT
     PRINT*, 'UNKNOWN ACTION:', ACTION
     STOP 1

  END SELECT

  DO TC = 1,NTRIALS
     PARTP=>PARTGROUP(TC)
     CALL CLEANUPPARTICLEGROUP(PARTP)
  END DO
  DEALLOCATE(PARTGROUP)

  CALL CPU_TIME(T2)
  PRINT*,''
  PRINT '(A8,F8.3,A1)','Runtime:', T2-T1,'s'

CONTAINS 
  SUBROUTINE BROWNDYNDRIVER(PARTGROUP)
    ! driver for brownian dynamics calculations
    USE BROWNDYN, ONLY : RUNBROWNDYNSIM
    USE KEYS, ONLY : BDSTEPS, DELT, KT, OUTFILE, BDPRINTEVERY, SNAPSHOTFILE,&
         & SNAPSHOTEVERY, APPENDSNAPSHOTS, DOBROWN, DUMPSNAPSHOTS, NTRIALS,RXNFILE
    IMPLICIT NONE

    TYPE(PARTICLEGROUP), TARGET :: PARTGROUP(NTRIALS)
    TYPE(PARTICLEGROUP), POINTER :: PARTP
    INTEGER :: SNAPEVERY, TC, WHICHREACT, WHICHTRACK, RXNTRACK
    DOUBLE PRECISION :: CURTIME,TRACKHITTIME
    LOGICAL :: MAKERXNFILE
    
    PARTP=>PARTGROUP(1)
    MAKERXNFILE = (PARTP%NRXN.GT.0.OR.PARTP%CHECKTRACKPART.GT.0)
    
    IF (MAKERXNFILE) THEN
       OPEN(UNIT=44,FILE=RXNFILE,STATUS='UNKNOWN')
    ENDIF

    IF (DUMPSNAPSHOTS) THEN
       SNAPEVERY = SNAPSHOTEVERY
    ELSE
       SNAPEVERY = HUGE(1)
    ENDIF

    DO TC = 1,NTRIALS
       PRINT*, 'ITERATION NUMBER: ',TC
       IF(TC.GT.1) APPENDSNAPSHOTS = .TRUE.
       PARTP=>PARTGROUP(TC)
       CALL  RUNBROWNDYNSIM(PARTP, BDSTEPS, DELT,KT,OUTFILE,BDPRINTEVERY,&
            & SNAPSHOTFILE,SNAPEVERY,APPENDSNAPSHOTS,DOBROWN,WHICHREACT, CURTIME,WHICHTRACK,TRACKHITTIME)

       ! output which, if any, particles reacted
       IF (WHICHREACT.GT.0) THEN
          RXNTRACK = PARTP%PARTTRACK(WHICHREACT) ! track to which reacted particle is attached
       ELSE
          RXNTRACK = 0
       ENDIF
       IF (MAKERXNFILE) WRITE(44,*) TC, WHICHREACT, CURTIME, RXNTRACK,WHICHTRACK,TRACKHITTIME
    END DO

    IF (MAKERXNFILE) CLOSE(44)
  END SUBROUTINE BROWNDYNDRIVER
END PROGRAM MAIN
